Materials:

1. Rename the current MaterialCustom to MaterialStandardCustom 

2 Create a new CustomMaterial where the consumer is able to define vertex and fragment shaders entirely
  Get run either in the geo-pass or the forward pass if transparent


Create a new package called webgpu-renderer-gltf-loader
Install @gltf-transform/core as its only dependency.

Use it to traverse file and map to our renderer primitives.
Provide a hook so that consumers can detect extras and work with them:

// In the application code (the consumer)
import { GLTFSceneLoader } from '@digitalmeadow/webgpu-renderer-gltf-importer';
const renderer = new Renderer(canvas);
const sceneLoader = new GLTFSceneLoader(renderer);
const vehicleController = new VehicleController();
// Assign our custom node processing logic
sceneLoader.onProcessNode = (gltfNode, entity) => {
  const extras = gltfNode.getExtras();
  if (extras.isVehicleBody) {
    vehicleController.setBody(entity);
  }
  if (extras.isWheel) {
    const wheelRadius = extras.wheelRadius || 0.3;
    vehicleController.addWheel(entity, wheelRadius);
    
    // By returning false, we could tell the loader to *not*
    // create a visible mesh for this node if it's just a physics helper.
    return false; 
  }
  // Return true for all other nodes to get default processing.
  return true;
};
// Load the scene. Our hooks will be called automatically.
await sceneLoader.load(world, gltfData);
