(function(C,R){typeof exports=="object"&&typeof module<"u"?R(exports):typeof define=="function"&&define.amd?define(["exports"],R):(C=typeof globalThis<"u"?globalThis:C||self,R(C.WebGPURenderer={}))})(this,(function(C){"use strict";class R{constructor(a=0,t=0){this.data=new Float32Array(2),this.data[0]=a,this.data[1]=t}get x(){return this.data[0]}set x(a){this.data[0]=a}get y(){return this.data[1]}set y(a){this.data[1]=a}set(a,t){return this.data[0]=a,this.data[1]=t,this}copy(){return new R(this.data[0],this.data[1])}clone(){return this.copy()}static create(a=0,t=0){return new R(a,t)}static copy(a,t){return t??=new R,t.data[0]=a.data[0],t.data[1]=a.data[1],t}static zero(){return new R(0,0)}static add(a,t,d){return d??=new R,d.data[0]=a.data[0]+t.data[0],d.data[1]=a.data[1]+t.data[1],d}static addScaled(a,t,d,n){return n??=new R,n.data[0]=a.data[0]+t.data[0]*d,n.data[1]=a.data[1]+t.data[1]*d,n}static sub(a,t,d){return d??=new R,d.data[0]=a.data[0]-t.data[0],d.data[1]=a.data[1]-t.data[1],d}static mul(a,t,d){return d??=new R,d.data[0]=a.data[0]*t.data[0],d.data[1]=a.data[1]*t.data[1],d}static div(a,t,d){return d??=new R,d.data[0]=a.data[0]/t.data[0],d.data[1]=a.data[1]/t.data[1],d}static scale(a,t,d){return d??=new R,d.data[0]=a.data[0]*t,d.data[1]=a.data[1]*t,d}static dot(a,t){return a.data[0]*t.data[0]+a.data[1]*t.data[1]}static len(a){return Math.sqrt(a.data[0]**2+a.data[1]**2)}static lengthSquared(a){return a.data[0]**2+a.data[1]**2}static normalize(a,t){t??=new R;const d=R.len(a);if(d>0){const n=1/d;t.data[0]=a.data[0]*n,t.data[1]=a.data[1]*n}return t}static distance(a,t){const d=a.data[0]-t.data[0],n=a.data[1]-t.data[1];return Math.sqrt(d*d+n*n)}static distanceSquared(a,t){const d=a.data[0]-t.data[0],n=a.data[1]-t.data[1];return d*d+n*n}static lerp(a,t,d,n){return n??=new R,n.data[0]=a.data[0]+d*(t.data[0]-a.data[0]),n.data[1]=a.data[1]+d*(t.data[1]-a.data[1]),n}static negate(a,t){return t??=new R,t.data[0]=-a.data[0],t.data[1]=-a.data[1],t}static inverse(a,t){return t??=new R,t.data[0]=1/a.data[0],t.data[1]=1/a.data[1],t}static min(a,t,d){return d??=new R,d.data[0]=Math.min(a.data[0],t.data[0]),d.data[1]=Math.min(a.data[1],t.data[1]),d}static max(a,t,d){return d??=new R,d.data[0]=Math.max(a.data[0],t.data[0]),d.data[1]=Math.max(a.data[1],t.data[1]),d}static clamp(a,t,d,n){return n??=new R,n.data[0]=Math.min(d,Math.max(t,a.data[0])),n.data[1]=Math.min(d,Math.max(t,a.data[1])),n}static ceil(a,t){return t??=new R,t.data[0]=Math.ceil(a.data[0]),t.data[1]=Math.ceil(a.data[1]),t}static floor(a,t){return t??=new R,t.data[0]=Math.floor(a.data[0]),t.data[1]=Math.floor(a.data[1]),t}static round(a,t){return t??=new R,t.data[0]=Math.round(a.data[0]),t.data[1]=Math.round(a.data[1]),t}static angle(a,t){const d=a.data[0],n=a.data[1],s=t.data[0],e=t.data[1],r=Math.sqrt(d*d+n*n),w=Math.sqrt(s*s+e*e),c=r*w,i=R.dot(a,t);return c>0?Math.acos(i/c):0}static random(a=1){const t=Math.random()*2*Math.PI;return new R(Math.cos(t)*a,Math.sin(t)*a)}static setLength(a,t,d){return d??=new R,R.normalize(a,d),R.scale(d,t,d),d}static truncate(a,t,d){return d??=new R,R.len(a)>t?R.setLength(a,t,d):R.copy(a,d),d}static midpoint(a,t,d){return R.lerp(a,t,.5,d)}static rotate(a,t,d,n){n??=new R;const s=a.data[0]-t.data[0],e=a.data[1]-t.data[1],r=Math.sin(d),w=Math.cos(d);return n.data[0]=s*w-e*r+t.data[0],n.data[1]=s*r+e*w+t.data[1],n}static equals(a,t,d=1e-6){return Math.abs(a.data[0]-t.data[0])<=d&&Math.abs(a.data[1]-t.data[1])<=d}static transformMat4(a,t,d){d??=new R;const n=a.data[0],s=a.data[1];return d.data[0]=n*t.data[0]+s*t.data[4]+t.data[12],d.data[1]=n*t.data[1]+s*t.data[5]+t.data[13],d}}class x{constructor(a=0,t=0,d=0){this.data=new Float32Array(3),this.data[0]=a,this.data[1]=t,this.data[2]=d}get x(){return this.data[0]}set x(a){this.data[0]=a}get y(){return this.data[1]}set y(a){this.data[1]=a}get z(){return this.data[2]}set z(a){this.data[2]=a}set(a,t,d){return this.data[0]=a,this.data[1]=t,this.data[2]=d,this}copy(){return new x(this.data[0],this.data[1],this.data[2])}clone(){return this.copy()}static create(a=0,t=0,d=0){return new x(a,t,d)}static copy(a,t){return t??=new x,t.data[0]=a.data[0],t.data[1]=a.data[1],t.data[2]=a.data[2],t}static zero(){return new x(0,0,0)}static add(a,t,d){return d??=new x,d.data[0]=a.data[0]+t.data[0],d.data[1]=a.data[1]+t.data[1],d.data[2]=a.data[2]+t.data[2],d}static addScaled(a,t,d,n){return n??=new x,n.data[0]=a.data[0]+t.data[0]*d,n.data[1]=a.data[1]+t.data[1]*d,n.data[2]=a.data[2]+t.data[2]*d,n}static sub(a,t,d){return d??=new x,d.data[0]=a.data[0]-t.data[0],d.data[1]=a.data[1]-t.data[1],d.data[2]=a.data[2]-t.data[2],d}static mul(a,t,d){return d??=new x,d.data[0]=a.data[0]*t.data[0],d.data[1]=a.data[1]*t.data[1],d.data[2]=a.data[2]*t.data[2],d}static div(a,t,d){return d??=new x,d.data[0]=a.data[0]/t.data[0],d.data[1]=a.data[1]/t.data[1],d.data[2]=a.data[2]/t.data[2],d}static scale(a,t,d){return d??=new x,d.data[0]=a.data[0]*t,d.data[1]=a.data[1]*t,d.data[2]=a.data[2]*t,d}static dot(a,t){return a.data[0]*t.data[0]+a.data[1]*t.data[1]+a.data[2]*t.data[2]}static cross(a,t,d){d??=new x;const n=a.data[0],s=a.data[1],e=a.data[2],r=t.data[0],w=t.data[1],c=t.data[2];return d.data[0]=s*c-e*w,d.data[1]=e*r-n*c,d.data[2]=n*w-s*r,d}static len(a){return Math.sqrt(a.data[0]**2+a.data[1]**2+a.data[2]**2)}static lengthSquared(a){return a.data[0]**2+a.data[1]**2+a.data[2]**2}static normalize(a,t){t??=new x;const d=x.len(a);if(d>0){const n=1/d;t.data[0]=a.data[0]*n,t.data[1]=a.data[1]*n,t.data[2]=a.data[2]*n}return t}static distance(a,t){const d=a.data[0]-t.data[0],n=a.data[1]-t.data[1],s=a.data[2]-t.data[2];return Math.sqrt(d*d+n*n+s*s)}static distanceSquared(a,t){const d=a.data[0]-t.data[0],n=a.data[1]-t.data[1],s=a.data[2]-t.data[2];return d*d+n*n+s*s}static lerp(a,t,d,n){return n??=new x,n.data[0]=a.data[0]+d*(t.data[0]-a.data[0]),n.data[1]=a.data[1]+d*(t.data[1]-a.data[1]),n.data[2]=a.data[2]+d*(t.data[2]-a.data[2]),n}static negate(a,t){return t??=new x,t.data[0]=-a.data[0],t.data[1]=-a.data[1],t.data[2]=-a.data[2],t}static inverse(a,t){return t??=new x,t.data[0]=1/a.data[0],t.data[1]=1/a.data[1],t.data[2]=1/a.data[2],t}static min(a,t,d){return d??=new x,d.data[0]=Math.min(a.data[0],t.data[0]),d.data[1]=Math.min(a.data[1],t.data[1]),d.data[2]=Math.min(a.data[2],t.data[2]),d}static max(a,t,d){return d??=new x,d.data[0]=Math.max(a.data[0],t.data[0]),d.data[1]=Math.max(a.data[1],t.data[1]),d.data[2]=Math.max(a.data[2],t.data[2]),d}static clamp(a,t,d,n){return n??=new x,n.data[0]=Math.min(d,Math.max(t,a.data[0])),n.data[1]=Math.min(d,Math.max(t,a.data[1])),n.data[2]=Math.min(d,Math.max(t,a.data[2])),n}static ceil(a,t){return t??=new x,t.data[0]=Math.ceil(a.data[0]),t.data[1]=Math.ceil(a.data[1]),t.data[2]=Math.ceil(a.data[2]),t}static floor(a,t){return t??=new x,t.data[0]=Math.floor(a.data[0]),t.data[1]=Math.floor(a.data[1]),t.data[2]=Math.floor(a.data[2]),t}static round(a,t){return t??=new x,t.data[0]=Math.round(a.data[0]),t.data[1]=Math.round(a.data[1]),t.data[2]=Math.round(a.data[2]),t}static angle(a,t){const d=a.data[0],n=a.data[1],s=a.data[2],e=t.data[0],r=t.data[1],w=t.data[2],c=Math.sqrt(d*d+n*n+s*s),i=Math.sqrt(e*e+r*r+w*w),h=c*i,M=x.dot(a,t);return h>0?Math.acos(M/h):0}static random(a=1){const t=Math.random()*2*Math.PI,d=Math.random()*2-1,n=Math.sqrt(1-d*d)*a;return new x(Math.cos(t)*n,Math.sin(t)*n,d*a)}static setLength(a,t,d){return d??=new x,x.normalize(a,d),x.scale(d,t,d),d}static truncate(a,t,d){return d??=new x,x.len(a)>t?x.setLength(a,t,d):x.copy(a,d),d}static midpoint(a,t,d){return x.lerp(a,t,.5,d)}static equals(a,t,d=1e-6){return Math.abs(a.data[0]-t.data[0])<=d&&Math.abs(a.data[1]-t.data[1])<=d&&Math.abs(a.data[2]-t.data[2])<=d}static transformMat4(a,t,d){d??=new x;const n=a.data[0],s=a.data[1],e=a.data[2],r=t.data[3]*n+t.data[7]*s+t.data[11]*e+t.data[15]||1;return d.data[0]=(t.data[0]*n+t.data[4]*s+t.data[8]*e+t.data[12])/r,d.data[1]=(t.data[1]*n+t.data[5]*s+t.data[9]*e+t.data[13])/r,d.data[2]=(t.data[2]*n+t.data[6]*s+t.data[10]*e+t.data[14])/r,d}static transformQuat(a,t,d){d??=new x;const n=t.data[0],s=t.data[1],e=t.data[2],r=t.data[3]*2,w=a.data[0],c=a.data[1],i=a.data[2],h=s*i-e*c,M=e*w-n*i,l=n*c-s*w;return d.data[0]=w+h*r+(s*l-e*M)*2,d.data[1]=c+M*r+(e*h-n*l)*2,d.data[2]=i+l*r+(n*M-s*h)*2,d}static rotateX(a,t,d,n){n??=new x;let s=[a.data[0]-t.data[0],a.data[1]-t.data[1],a.data[2]-t.data[2]],e;return e=[s[0],s[1]*Math.cos(d)-s[2]*Math.sin(d),s[1]*Math.sin(d)+s[2]*Math.cos(d)],n.data[0]=e[0]+t.data[0],n.data[1]=e[1]+t.data[1],n.data[2]=e[2]+t.data[2],n}static rotateY(a,t,d,n){n??=new x;let s=[a.data[0]-t.data[0],a.data[1]-t.data[1],a.data[2]-t.data[2]],e;return e=[s[2]*Math.sin(d)+s[0]*Math.cos(d),s[1],s[2]*Math.cos(d)-s[0]*Math.sin(d)],n.data[0]=e[0]+t.data[0],n.data[1]=e[1]+t.data[1],n.data[2]=e[2]+t.data[2],n}static rotateZ(a,t,d,n){n??=new x;let s=[a.data[0]-t.data[0],a.data[1]-t.data[1],a.data[2]-t.data[2]],e;return e=[s[0]*Math.cos(d)-s[1]*Math.sin(d),s[0]*Math.sin(d)+s[1]*Math.cos(d),s[2]],n.data[0]=e[0]+t.data[0],n.data[1]=e[1]+t.data[1],n.data[2]=e[2]+t.data[2],n}}class L{constructor(a=0,t=0,d=0,n=0){this.data=new Float32Array(4),this.data[0]=a,this.data[1]=t,this.data[2]=d,this.data[3]=n}get x(){return this.data[0]}set x(a){this.data[0]=a}get y(){return this.data[1]}set y(a){this.data[1]=a}get z(){return this.data[2]}set z(a){this.data[2]=a}get w(){return this.data[3]}set w(a){this.data[3]=a}set(a,t,d,n){return this.data[0]=a,this.data[1]=t,this.data[2]=d,this.data[3]=n,this}copy(){return new L(this.data[0],this.data[1],this.data[2],this.data[3])}clone(){return this.copy()}static create(a=0,t=0,d=0,n=0){return new L(a,t,d,n)}static add(a,t,d){return d??=new L,d.data[0]=a.data[0]+t.data[0],d.data[1]=a.data[1]+t.data[1],d.data[2]=a.data[2]+t.data[2],d.data[3]=a.data[3]+t.data[3],d}static sub(a,t,d){return d??=new L,d.data[0]=a.data[0]-t.data[0],d.data[1]=a.data[1]-t.data[1],d.data[2]=a.data[2]-t.data[2],d.data[3]=a.data[3]-t.data[3],d}static scale(a,t,d){return d??=new L,d.data[0]=a.data[0]*t,d.data[1]=a.data[1]*t,d.data[2]=a.data[2]*t,d.data[3]=a.data[3]*t,d}static dot(a,t){return a.data[0]*t.data[0]+a.data[1]*t.data[1]+a.data[2]*t.data[2]+a.data[3]*t.data[3]}static len(a){return Math.sqrt(a.data[0]**2+a.data[1]**2+a.data[2]**2+a.data[3]**2)}static lengthSquared(a){return a.data[0]**2+a.data[1]**2+a.data[2]**2+a.data[3]**2}static normalize(a,t){t??=new L;const d=L.len(a);return d>0&&(t.data[0]=a.data[0]/d,t.data[1]=a.data[1]/d,t.data[2]=a.data[2]/d,t.data[3]=a.data[3]/d),t}static distance(a,t){return L.len(L.sub(a,t))}static lerp(a,t,d,n){return n??=new L,n.data[0]=a.data[0]+d*(t.data[0]-a.data[0]),n.data[1]=a.data[1]+d*(t.data[1]-a.data[1]),n.data[2]=a.data[2]+d*(t.data[2]-a.data[2]),n.data[3]=a.data[3]+d*(t.data[3]-a.data[3]),n}static negate(a,t){return t??=new L,t.data[0]=-a.data[0],t.data[1]=-a.data[1],t.data[2]=-a.data[2],t.data[3]=-a.data[3],t}static equals(a,t,d=1e-6){return Math.abs(a.data[0]-t.data[0])<=d&&Math.abs(a.data[1]-t.data[1])<=d&&Math.abs(a.data[2]-t.data[2])<=d&&Math.abs(a.data[3]-t.data[3])<=d}}class k{constructor(a=0,t=0,d=0,n=1){this.data=new Float32Array(4),this.data[0]=a,this.data[1]=t,this.data[2]=d,this.data[3]=n}get x(){return this.data[0]}set x(a){this.data[0]=a}get y(){return this.data[1]}set y(a){this.data[1]=a}get z(){return this.data[2]}set z(a){this.data[2]=a}get w(){return this.data[3]}set w(a){this.data[3]=a}set(a,t,d,n){return this.data[0]=a,this.data[1]=t,this.data[2]=d,this.data[3]=n,this}copy(){return new k(this.data[0],this.data[1],this.data[2],this.data[3])}clone(){return this.copy()}static identity(){return new k(0,0,0,1)}static create(a=0,t=0,d=0,n=1){return new k(a,t,d,n)}static zero(){return new k(0,0,0,0)}static copy(a,t){return t??=new k,t.data[0]=a.data[0],t.data[1]=a.data[1],t.data[2]=a.data[2],t.data[3]=a.data[3],t}static fromAxisAngle(a,t){const d=t*.5,n=Math.sin(d);return new k(a.data[0]*n,a.data[1]*n,a.data[2]*n,Math.cos(d))}static toAxisAngle(a){const t=Math.acos(a.data[3])*2,d=Math.sin(t*.5),n=new x;return d>1e-6?(n.data[0]=a.data[0]/d,n.data[1]=a.data[1]/d,n.data[2]=a.data[2]/d):(n.data[0]=1,n.data[1]=0,n.data[2]=0),{angle:t,axis:n}}static multiply(a,t,d){d??=new k;const n=a.data[0],s=a.data[1],e=a.data[2],r=a.data[3],w=t.data[0],c=t.data[1],i=t.data[2],h=t.data[3];return d.data[0]=n*h+r*w+s*i-e*c,d.data[1]=s*h+r*c+e*w-n*i,d.data[2]=e*h+r*i+n*c-s*w,d.data[3]=r*h-n*w-s*c-e*i,d}static slerp(a,t,d,n){n??=new k;let s=a.data[0],e=a.data[1],r=a.data[2],w=a.data[3],c=t.data[0],i=t.data[1],h=t.data[2],M=t.data[3],l=s*c+e*i+r*h+w*M;l<0&&(l=-l,c=-c,i=-i,h=-h,M=-M);let y,z;if(1-l>1e-6){const p=Math.acos(l),f=Math.sin(p);y=Math.sin((1-d)*p)/f,z=Math.sin(d*p)/f}else y=1-d,z=d;return n.data[0]=y*s+z*c,n.data[1]=y*e+z*i,n.data[2]=y*r+z*h,n.data[3]=y*w+z*M,n}static len(a){return Math.sqrt(a.data[0]**2+a.data[1]**2+a.data[2]**2+a.data[3]**2)}static lengthSquared(a){return a.data[0]**2+a.data[1]**2+a.data[2]**2+a.data[3]**2}static normalize(a,t){t??=new k;const d=k.len(a);if(d>1e-5){const n=1/d;t.data[0]=a.data[0]*n,t.data[1]=a.data[1]*n,t.data[2]=a.data[2]*n,t.data[3]=a.data[3]*n}else t.data[0]=0,t.data[1]=0,t.data[2]=0,t.data[3]=1;return t}static invert(a,t){t??=new k;const d=a.data[0],n=a.data[1],s=a.data[2],e=a.data[3],r=d*d+n*n+s*s+e*e,w=r>0?1/r:0;return t.data[0]=-d*w,t.data[1]=-n*w,t.data[2]=-s*w,t.data[3]=e*w,t}static conjugate(a,t){return t??=new k,t.data[0]=-a.data[0],t.data[1]=-a.data[1],t.data[2]=-a.data[2],t.data[3]=a.data[3],t}static fromEuler(a,t,d,n){return n??=new k,k.fromEulerOrder(a,t,d,"xyz",n)}static fromEulerOrder(a,t,d,n,s){s??=new k;const e=a*.5,r=t*.5,w=d*.5,c=Math.sin(e),i=Math.cos(e),h=Math.sin(r),M=Math.cos(r),l=Math.sin(w),y=Math.cos(w);switch(n){case"xyz":s.data[0]=c*M*y+i*h*l,s.data[1]=i*h*y-c*M*l,s.data[2]=i*M*l+c*h*y,s.data[3]=i*M*y-c*h*l;break;case"xzy":s.data[0]=c*M*y-i*h*l,s.data[1]=i*h*y-c*M*l,s.data[2]=i*M*l+c*h*y,s.data[3]=i*M*y+c*h*l;break;case"yxz":s.data[0]=c*M*y+i*h*l,s.data[1]=i*h*y-c*M*l,s.data[2]=i*M*l-c*h*y,s.data[3]=i*M*y+c*h*l;break;case"yzx":s.data[0]=c*M*y+i*h*l,s.data[1]=i*h*y+c*M*l,s.data[2]=i*M*l-c*h*y,s.data[3]=i*M*y-c*h*l;break;case"zxy":s.data[0]=c*M*y-i*h*l,s.data[1]=i*h*y+c*M*l,s.data[2]=i*M*l+c*h*y,s.data[3]=i*M*y-c*h*l;break;case"zyx":s.data[0]=c*M*y-i*h*l,s.data[1]=i*h*y+c*M*l,s.data[2]=i*M*l-c*h*y,s.data[3]=i*M*y+c*h*l;break}return s}static fromMat(a,t){t??=new k;const d=a.data[0],n=a.data[1],s=a.data[2],e=a.data[4],r=a.data[5],w=a.data[6],c=a.data[8],i=a.data[9],h=a.data[10],M=d+r+h;if(M>0){const l=Math.sqrt(M+1);t.data[3]=.5*l;const y=.5/l;t.data[0]=(i-w)*y,t.data[1]=(s-c)*y,t.data[2]=(e-n)*y}else if(d>r&&d>h){const l=Math.sqrt(1+d-r-h);t.data[0]=.5*l;const y=.5/l;t.data[1]=(n+e)*y,t.data[2]=(s+c)*y,t.data[3]=(i-w)*y}else if(r>h){const l=Math.sqrt(1+r-d-h);t.data[1]=.5*l;const y=.5/l;t.data[0]=(n+e)*y,t.data[2]=(w+i)*y,t.data[3]=(s-c)*y}else{const l=Math.sqrt(1+h-d-r);t.data[2]=.5*l;const y=.5/l;t.data[0]=(s+c)*y,t.data[1]=(w+i)*y,t.data[3]=(e-n)*y}return t}static dot(a,t){return a.data[0]*t.data[0]+a.data[1]*t.data[1]+a.data[2]*t.data[2]+a.data[3]*t.data[3]}static add(a,t,d){return d??=new k,d.data[0]=a.data[0]+t.data[0],d.data[1]=a.data[1]+t.data[1],d.data[2]=a.data[2]+t.data[2],d.data[3]=a.data[3]+t.data[3],d}static sub(a,t,d){return d??=new k,d.data[0]=a.data[0]-t.data[0],d.data[1]=a.data[1]-t.data[1],d.data[2]=a.data[2]-t.data[2],d.data[3]=a.data[3]-t.data[3],d}static scale(a,t,d){return d??=new k,d.data[0]=a.data[0]*t,d.data[1]=a.data[1]*t,d.data[2]=a.data[2]*t,d.data[3]=a.data[3]*t,d}static lerp(a,t,d,n){return n??=new k,n.data[0]=a.data[0]+d*(t.data[0]-a.data[0]),n.data[1]=a.data[1]+d*(t.data[1]-a.data[1]),n.data[2]=a.data[2]+d*(t.data[2]-a.data[2]),n.data[3]=a.data[3]+d*(t.data[3]-a.data[3]),n}static angle(a,t){const d=k.dot(a,t);return Math.acos(2*d*d-1)}static rotateX(a,t,d){d??=new k;const n=t*.5,s=a.data[0],e=a.data[1],r=a.data[2],w=a.data[3],c=Math.sin(n),i=Math.cos(n);return d.data[0]=s*i+w*c,d.data[1]=e*i+r*c,d.data[2]=r*i-e*c,d.data[3]=w*i-s*c,d}static rotateY(a,t,d){d??=new k;const n=t*.5,s=a.data[0],e=a.data[1],r=a.data[2],w=a.data[3],c=Math.sin(n),i=Math.cos(n);return d.data[0]=s*i-r*c,d.data[1]=e*i+w*c,d.data[2]=r*i+s*c,d.data[3]=w*i-e*c,d}static rotateZ(a,t,d){d??=new k;const n=t*.5,s=a.data[0],e=a.data[1],r=a.data[2],w=a.data[3],c=Math.sin(n),i=Math.cos(n);return d.data[0]=s*i+e*c,d.data[1]=e*i-s*c,d.data[2]=r*i+w*c,d.data[3]=w*i-r*c,d}static rotationTo(a,t,d){d??=new k;const n=x.dot(a,t);if(n<-.999999){const s=x.cross(a,new x(1,0,0));x.len(s)<1e-6&&x.cross(a,new x(0,1,0),s),x.normalize(s,s);const e=k.fromAxisAngle(s,Math.PI);return d.set(e.data[0],e.data[1],e.data[2],e.data[3]),d}else return n>.999999?(d.data[0]=0,d.data[1]=0,d.data[2]=0,d.data[3]=1,d):(x.cross(a,t,G),d.data[0]=G.data[0],d.data[1]=G.data[1],d.data[2]=G.data[2],d.data[3]=1+n,k.normalize(d,d))}static sqlerp(a,t,d,n,s,e){e??=new k;const r=k.slerp(a,n,s),w=k.slerp(t,d,s);return k.slerp(r,w,2*s*(1-s),e)}static equals(a,t,d=1e-6){return Math.abs(a.data[0]-t.data[0])<=d&&Math.abs(a.data[1]-t.data[1])<=d&&Math.abs(a.data[2]-t.data[2])<=d&&Math.abs(a.data[3]-t.data[3])<=d}}const G=new x;class P{constructor(){this.data=new Float32Array(16),this.data.fill(0),this.data[0]=1,this.data[5]=1,this.data[10]=1,this.data[15]=1}static identity(){return new P}static create(){return new P}static copy(a,t){return t??=new P,t.data.set(a.data),t}static clone(a){return P.copy(a)}static multiply(a,t,d){d??=new P;const n=a.data[0],s=a.data[1],e=a.data[2],r=a.data[3],w=a.data[4],c=a.data[5],i=a.data[6],h=a.data[7],M=a.data[8],l=a.data[9],y=a.data[10],z=a.data[11],p=a.data[12],f=a.data[13],v=a.data[14],T=a.data[15];let g=t.data[0],A=t.data[1],q=t.data[2],S=t.data[3];return d.data[0]=g*n+A*w+q*M+S*p,d.data[1]=g*s+A*c+q*l+S*f,d.data[2]=g*e+A*i+q*y+S*v,d.data[3]=g*r+A*h+q*z+S*T,g=t.data[4],A=t.data[5],q=t.data[6],S=t.data[7],d.data[4]=g*n+A*w+q*M+S*p,d.data[5]=g*s+A*c+q*l+S*f,d.data[6]=g*e+A*i+q*y+S*v,d.data[7]=g*r+A*h+q*z+S*T,g=t.data[8],A=t.data[9],q=t.data[10],S=t.data[11],d.data[8]=g*n+A*w+q*M+S*p,d.data[9]=g*s+A*c+q*l+S*f,d.data[10]=g*e+A*i+q*y+S*v,d.data[11]=g*r+A*h+q*z+S*T,g=t.data[12],A=t.data[13],q=t.data[14],S=t.data[15],d.data[12]=g*n+A*w+q*M+S*p,d.data[13]=g*s+A*c+q*l+S*f,d.data[14]=g*e+A*i+q*y+S*v,d.data[15]=g*r+A*h+q*z+S*T,d}static invert(a,t){t??=new P;const d=a.data[0],n=a.data[1],s=a.data[2],e=a.data[3],r=a.data[4],w=a.data[5],c=a.data[6],i=a.data[7],h=a.data[8],M=a.data[9],l=a.data[10],y=a.data[11],z=a.data[12],p=a.data[13],f=a.data[14],v=a.data[15],T=d*w-n*r,g=d*c-s*r,A=d*i-e*r,q=n*c-s*w,S=n*i-e*w,O=s*i-e*c,X=h*p-M*z,Y=h*f-l*z,Z=h*v-y*z,j=M*f-l*p,E=M*v-y*p,I=l*v-y*f;let F=T*I-g*E+A*j+q*Z-S*Y+O*X;return F?(F=1/F,t.data[0]=(w*I-c*E+i*j)*F,t.data[1]=(s*E-n*I-e*j)*F,t.data[2]=(p*O-f*S+v*q)*F,t.data[3]=(l*S-M*O-y*q)*F,t.data[4]=(c*Z-r*I-i*Y)*F,t.data[5]=(d*I-s*Z+e*Y)*F,t.data[6]=(f*A-z*O-v*g)*F,t.data[7]=(h*O-l*A+y*g)*F,t.data[8]=(r*E-w*Z+i*X)*F,t.data[9]=(n*Z-d*E-e*X)*F,t.data[10]=(z*S-p*A+v*T)*F,t.data[11]=(M*A-h*S-y*T)*F,t.data[12]=(w*Y-r*j-c*X)*F,t.data[13]=(d*j-n*Y+s*X)*F,t.data[14]=(p*g-z*q-f*T)*F,t.data[15]=(h*q-M*g+l*T)*F,t):null}static determinant(a){const t=a.data[0],d=a.data[1],n=a.data[2],s=a.data[3],e=a.data[4],r=a.data[5],w=a.data[6],c=a.data[7],i=a.data[8],h=a.data[9],M=a.data[10],l=a.data[11],y=a.data[12],z=a.data[13],p=a.data[14],f=a.data[15],v=M*f,T=p*l,g=w*f,A=p*c,q=w*l,S=M*c,O=n*f,X=p*s,Y=n*l,Z=M*s,j=n*c,E=w*s,I=v*r+A*h+q*z-(T*r+g*h+S*z),F=T*d+O*h+Z*z-(v*d+X*h+Y*z),D=g*d+X*r+j*z-(A*d+O*r+E*z),U=S*d+Y*r+E*h-(q*d+Z*r+j*h);return t*I+e*F+i*D+y*U}static transpose(a,t){if(t??=new P,a===t){const d=a.data[1],n=a.data[2],s=a.data[3],e=a.data[6],r=a.data[7],w=a.data[11];t.data[1]=a.data[4],t.data[2]=a.data[8],t.data[3]=a.data[12],t.data[4]=d,t.data[6]=a.data[9],t.data[7]=a.data[13],t.data[8]=n,t.data[9]=e,t.data[11]=a.data[14],t.data[12]=s,t.data[13]=r,t.data[14]=w}else t.data[0]=a.data[0],t.data[1]=a.data[4],t.data[2]=a.data[8],t.data[3]=a.data[12],t.data[4]=a.data[1],t.data[5]=a.data[5],t.data[6]=a.data[9],t.data[7]=a.data[13],t.data[8]=a.data[2],t.data[9]=a.data[6],t.data[10]=a.data[10],t.data[11]=a.data[14],t.data[12]=a.data[3],t.data[13]=a.data[7],t.data[14]=a.data[11],t.data[15]=a.data[15];return t}static translate(a,t,d){d??=new P;const n=t.data[0],s=t.data[1],e=t.data[2];if(a===d)d.data[12]=a.data[0]*n+a.data[4]*s+a.data[8]*e+a.data[12],d.data[13]=a.data[1]*n+a.data[5]*s+a.data[9]*e+a.data[13],d.data[14]=a.data[2]*n+a.data[6]*s+a.data[10]*e+a.data[14],d.data[15]=a.data[3]*n+a.data[7]*s+a.data[11]*e+a.data[15];else{const r=a.data[0],w=a.data[1],c=a.data[2],i=a.data[3],h=a.data[4],M=a.data[5],l=a.data[6],y=a.data[7],z=a.data[8],p=a.data[9],f=a.data[10],v=a.data[11];d.data[0]=r,d.data[1]=w,d.data[2]=c,d.data[3]=i,d.data[4]=h,d.data[5]=M,d.data[6]=l,d.data[7]=y,d.data[8]=z,d.data[9]=p,d.data[10]=f,d.data[11]=v,d.data[12]=r*n+h*s+z*e+a.data[12],d.data[13]=w*n+M*s+p*e+a.data[13],d.data[14]=c*n+l*s+f*e+a.data[14],d.data[15]=i*n+y*s+v*e+a.data[15]}return d}static scale(a,t,d){d??=new P;const n=t.data[0],s=t.data[1],e=t.data[2];return d.data[0]=a.data[0]*n,d.data[1]=a.data[1]*n,d.data[2]=a.data[2]*n,d.data[3]=a.data[3]*n,d.data[4]=a.data[4]*s,d.data[5]=a.data[5]*s,d.data[6]=a.data[6]*s,d.data[7]=a.data[7]*s,d.data[8]=a.data[8]*e,d.data[9]=a.data[9]*e,d.data[10]=a.data[10]*e,d.data[11]=a.data[11]*e,d.data[12]=a.data[12],d.data[13]=a.data[13],d.data[14]=a.data[14],d.data[15]=a.data[15],d}static rotate(a,t,d,n){n??=new P;let s=d.data[0],e=d.data[1],r=d.data[2],w=Math.sqrt(s*s+e*e+r*r);if(w<1e-6)return null;w=1/w,s*=w,e*=w,r*=w;const c=Math.sin(t),i=Math.cos(t),h=1-i,M=a.data[0],l=a.data[1],y=a.data[2],z=a.data[3],p=a.data[4],f=a.data[5],v=a.data[6],T=a.data[7],g=a.data[8],A=a.data[9],q=a.data[10],S=a.data[11],O=s*s*h+i,X=e*s*h+r*c,Y=r*s*h-e*c,Z=s*e*h-r*c,j=e*e*h+i,E=r*e*h+s*c,I=s*r*h+e*c,F=e*r*h-s*c,D=r*r*h+i;return n.data[0]=M*O+p*X+g*Y,n.data[1]=l*O+f*X+A*Y,n.data[2]=y*O+v*X+q*Y,n.data[3]=z*O+T*X+S*Y,n.data[4]=M*Z+p*j+g*E,n.data[5]=l*Z+f*j+A*E,n.data[6]=y*Z+v*j+q*E,n.data[7]=z*Z+T*j+S*E,n.data[8]=M*I+p*F+g*D,n.data[9]=l*I+f*F+A*D,n.data[10]=y*I+v*F+q*D,n.data[11]=z*I+T*F+S*D,a!==n&&(n.data[12]=a.data[12],n.data[13]=a.data[13],n.data[14]=a.data[14],n.data[15]=a.data[15]),n}static rotateX(a,t,d){d??=new P;const n=Math.sin(t),s=Math.cos(t),e=a.data[4],r=a.data[5],w=a.data[6],c=a.data[7],i=a.data[8],h=a.data[9],M=a.data[10],l=a.data[11];return a!==d&&(d.data[0]=a.data[0],d.data[1]=a.data[1],d.data[2]=a.data[2],d.data[3]=a.data[3],d.data[12]=a.data[12],d.data[13]=a.data[13],d.data[14]=a.data[14],d.data[15]=a.data[15]),d.data[4]=e*s+i*n,d.data[5]=r*s+h*n,d.data[6]=w*s+M*n,d.data[7]=c*s+l*n,d.data[8]=i*s-e*n,d.data[9]=h*s-r*n,d.data[10]=M*s-w*n,d.data[11]=l*s-c*n,d}static rotateY(a,t,d){d??=new P;const n=Math.sin(t),s=Math.cos(t),e=a.data[0],r=a.data[1],w=a.data[2],c=a.data[3],i=a.data[8],h=a.data[9],M=a.data[10],l=a.data[11];return a!==d&&(d.data[4]=a.data[4],d.data[5]=a.data[5],d.data[6]=a.data[6],d.data[7]=a.data[7],d.data[12]=a.data[12],d.data[13]=a.data[13],d.data[14]=a.data[14],d.data[15]=a.data[15]),d.data[0]=e*s-i*n,d.data[1]=r*s-h*n,d.data[2]=w*s-M*n,d.data[3]=c*s-l*n,d.data[8]=e*n+i*s,d.data[9]=r*n+h*s,d.data[10]=w*n+M*s,d.data[11]=c*n+l*s,d}static rotateZ(a,t,d){d??=new P;const n=Math.sin(t),s=Math.cos(t),e=a.data[0],r=a.data[1],w=a.data[2],c=a.data[3],i=a.data[4],h=a.data[5],M=a.data[6],l=a.data[7];return a!==d&&(d.data[8]=a.data[8],d.data[9]=a.data[9],d.data[10]=a.data[10],d.data[11]=a.data[11],d.data[12]=a.data[12],d.data[13]=a.data[13],d.data[14]=a.data[14],d.data[15]=a.data[15]),d.data[0]=e*s+i*n,d.data[1]=r*s+h*n,d.data[2]=w*s+M*n,d.data[3]=c*s+l*n,d.data[4]=i*s-e*n,d.data[5]=h*s-r*n,d.data[6]=M*s-w*n,d.data[7]=l*s-c*n,d}static fromQuat(a,t){t??=new P;const d=a.data[0],n=a.data[1],s=a.data[2],e=a.data[3],r=d+d,w=n+n,c=s+s,i=d*r,h=n*r,M=n*w,l=s*r,y=s*w,z=s*c,p=e*r,f=e*w,v=e*c;return t.data[0]=1-M-z,t.data[1]=h+v,t.data[2]=l-f,t.data[3]=0,t.data[4]=h-v,t.data[5]=1-i-z,t.data[6]=y+p,t.data[7]=0,t.data[8]=l+f,t.data[9]=y-p,t.data[10]=1-i-M,t.data[11]=0,t.data[12]=0,t.data[13]=0,t.data[14]=0,t.data[15]=1,t}static fromRotationTranslationScale(a,t,d,n){n??=new P;const s=a.data[0],e=a.data[1],r=a.data[2],w=a.data[3],c=s+s,i=e+e,h=r+r,M=s*c,l=s*i,y=s*h,z=e*i,p=e*h,f=r*h,v=w*c,T=w*i,g=w*h,A=d.data[0],q=d.data[1],S=d.data[2];return n.data[0]=(1-(z+f))*A,n.data[1]=(l+g)*A,n.data[2]=(y-T)*A,n.data[3]=0,n.data[4]=(l-g)*q,n.data[5]=(1-(M+f))*q,n.data[6]=(p+v)*q,n.data[7]=0,n.data[8]=(y+T)*S,n.data[9]=(p-v)*S,n.data[10]=(1-(M+z))*S,n.data[11]=0,n.data[12]=t.data[0],n.data[13]=t.data[1],n.data[14]=t.data[2],n.data[15]=1,n}static fromRotationTranslationScaleOrigin(a,t,d,n,s){s??=new P;const e=a.data[0],r=a.data[1],w=a.data[2],c=a.data[3],i=e+e,h=r+r,M=w+w,l=e*i,y=e*h,z=e*M,p=r*h,f=r*M,v=w*M,T=c*i,g=c*h,A=c*M,q=d.data[0],S=d.data[1],O=d.data[2],X=n.data[0],Y=n.data[1],Z=n.data[2],j=X*p+Z*f-Y*v,E=Y*l+Z*z-X*f,I=X*f+Y*z-Z*l;return s.data[0]=(1-(p+v))*q,s.data[1]=(y+A)*q,s.data[2]=(z-g)*q,s.data[3]=0,s.data[4]=(y-A)*S,s.data[5]=(1-(l+v))*S,s.data[6]=(f+T)*S,s.data[7]=0,s.data[8]=(z+g)*O,s.data[9]=(f-T)*O,s.data[10]=(1-(l+p))*O,s.data[11]=0,s.data[12]=t.data[0]-j*q,s.data[13]=t.data[1]-E*S,s.data[14]=t.data[2]-I*O,s.data[15]=1,s}static getTranslation(a,t){return t??=new x,t.data[0]=a.data[12],t.data[1]=a.data[13],t.data[2]=a.data[14],t}static getRotation(a,t){t??=new k;const d=a.data[0],n=a.data[1],s=a.data[2],e=a.data[4],r=a.data[5],w=a.data[6],c=a.data[8],i=a.data[9],h=a.data[10],M=d+r+h;let l=0;return M>0?(l=Math.sqrt(M+1)*2,t.data[3]=.25*l,t.data[0]=(i-w)/l,t.data[1]=(s-c)/l,t.data[2]=(e-n)/l):d>r&&d>h?(l=Math.sqrt(1+d-r-h)*2,t.data[3]=(i-w)/l,t.data[0]=.25*l,t.data[1]=(n+e)/l,t.data[2]=(s+c)/l):r>h?(l=Math.sqrt(1+r-d-h)*2,t.data[3]=(s-c)/l,t.data[0]=(n+e)/l,t.data[1]=.25*l,t.data[2]=(w+i)/l):(l=Math.sqrt(1+h-d-r)*2,t.data[3]=(e-n)/l,t.data[0]=(s+c)/l,t.data[1]=(w+i)/l,t.data[2]=.25*l),t}static getScaling(a,t){t??=new x;const d=a.data[0],n=a.data[1],s=a.data[2],e=a.data[4],r=a.data[5],w=a.data[6],c=a.data[8],i=a.data[9],h=a.data[10];return t.data[0]=Math.sqrt(d*d+n*n+s*s),t.data[1]=Math.sqrt(e*e+r*r+w*w),t.data[2]=Math.sqrt(c*c+i*i+h*h),t}static perspective(a,t,d,n,s){s??=new P;const e=1/Math.tan(a/2),r=1/(d-n);return s.data[0]=e/t,s.data[1]=0,s.data[2]=0,s.data[3]=0,s.data[4]=0,s.data[5]=e,s.data[6]=0,s.data[7]=0,s.data[8]=0,s.data[9]=0,s.data[10]=(n+d)*r,s.data[11]=-1,s.data[12]=0,s.data[13]=0,s.data[14]=2*n*d*r,s.data[15]=0,s}static ortho(a,t,d,n,s,e,r){r??=new P;const w=1/(a-t),c=1/(d-n),i=1/(s-e);return r.data[0]=-2*w,r.data[1]=0,r.data[2]=0,r.data[3]=0,r.data[4]=0,r.data[5]=-2*c,r.data[6]=0,r.data[7]=0,r.data[8]=0,r.data[9]=0,r.data[10]=2*i,r.data[11]=0,r.data[12]=(a+t)*w,r.data[13]=(n+d)*c,r.data[14]=(e+s)*i,r.data[15]=1,r}static lookAt(a,t,d,n){n??=new P;const s=a.data[0],e=a.data[1],r=a.data[2],w=t.data[0],c=t.data[1],i=t.data[2],h=d.data[0],M=d.data[1],l=d.data[2];let y=s-w,z=e-c,p=r-i,f=y*y+z*z+p*p;f>0&&(f=1/Math.sqrt(f),y*=f,z*=f,p*=f);let v=M*p-l*z,T=l*y-h*p,g=h*z-M*y;f=v*v+T*T+g*g,f>0&&(f=1/Math.sqrt(f),v*=f,T*=f,g*=f);const A=z*g-p*T,q=p*v-y*g,S=y*T-z*v;return n.data[0]=v,n.data[1]=A,n.data[2]=y,n.data[3]=0,n.data[4]=T,n.data[5]=q,n.data[6]=z,n.data[7]=0,n.data[8]=g,n.data[9]=S,n.data[10]=p,n.data[11]=0,n.data[12]=-(v*s+T*e+g*r),n.data[13]=-(A*s+q*e+S*r),n.data[14]=-(y*s+z*e+p*r),n.data[15]=1,n}}C.Mat4=P,C.Quat=k,C.Vec2=R,C.Vec3=x,C.Vec4=L,Object.defineProperty(C,Symbol.toStringTag,{value:"Module"})}));
